@startuml Diagrama de clases - Entrega 2 - v2

skinparam linetype ortho

FuenteDeDatos --* Coleccion
Criterio -up-* Coleccion
Hecho --o Multimedia
Hecho --o Perfil
SolicitudEliminacion -- EstadoSolicitud
SolicitudEliminacion *-- Hecho
SolicitudEliminacion *-- Perfil
Hecho --* FuenteDeDatos
cargarHechoCSV -- FuenteEstatica
Usuario -- Rol
DetectorDeSpamService -- DetectorDeSpam
DetectorDeSpamService --> SolicitudEliminacion
Hecho --* Ubicacion
Perfil --* Usuario
Multimedia -- TipoMultimedia

/'
Tipo	Símbolo	Finalidad
Extensión	<|--	Especialización de una clase en una jerarquía
Implementación	<|..	Realización de una interfaz mediante una clase
Composición	*--	La parte no puede existir sin el todo
Agregación	o--	La parte puede existir independientemente del todo
Dependencia	-->	El objeto utiliza otro objeto
Dependencia	..>	Una forma más débil de dependencia

'/
' Al trabajar solo con un rol de usuario, no es necesario crear una jerarquía de clases para los roles. En su lugar, se puede utilizar un enum para definir los diferentes tipos de usuario y sus permisos asociados. Esto simplifica el diseño y evita la complejidad innecesaria de una jerarquía de clases.
'Por ejemplo cuando se quiera crear una coleccion, coleccion va a realizar la validacion si ese contribuyente (contribuyente como entidad que refleja a los usuarios que utilizan la plataforma admin,contribuyente visualizador) que solicito crear tiene los permisos necesarios y asi con todos los metodos.
'No necesitamos un visualizador ya que este solo va a acceder a la plataforma y los metodos que no requieran una autenticacion.
'-----------------Hechos----------------
class Hecho {
    +titulo: String
    +descripcion: String
    +categoria: String
    +ubicacion: Ubicacion
    +fechaHecho: Date
    +fechaCarga: Date
    +fuente: FuenteDeDatos
    +autor: Perfil
    -anonimo: Boolean
    -eliminado: Boolean
    +multimedia : List<Multimedia>
    +metadata: List<String> 
    {method} añadirEtiqueta(metadata:String)
    {method}getNombreAutor() 
    'verifica si no tiene un usuario asociado va a buscar el nombre de la fuente y si tiene devuelve el nombre del usuario.
}

class Ubicacion{
    +latitud: Float
    +longitud: Float
}

class Multimedia{
    tipo: TipoMultimedia
    +path: String
} 
enum TipoMultimedia {
  FOTO
  VIDEO
  AUDIO
}
'No van a tener comportamiento, el front se va a encargar de mostrar los archivos multimedia de acuerdo al tipo que tengan y su url para buscarlos 

class cargarHechoCSV{
    +path: String
    +fuente: FuenteEstatica
    {method} cargarHecho(path:String, fuente:FuenteEstatica) 
    'recorre el archivo CSV, crea los hechos y los añade en la fuente de datos estática, consultar si se hace generico para porder utiilizarlo en la fuente proxy tambien, es decir si la carga de la fuente proxy se hace mediante un csv pero desde una url(web) la funcionaliudad vendriua a ser la misma y se podria implementar un importadorHechos.

}

'-----------------Fuentes de datos----------------

interface FuenteDeDatos{
    +nombre: String
    +hechos: List<Hecho>
    {method}agregarHecho()
}

class FuenteEstatica implements FuenteDeDatos{
    {method}agregarHecho(titulo:String, descripcion:String, ubicacion: Ubicacion, categoria: String, multimedia: Multimedia, fecha:Date)
}

class FuenteDinamica implements FuenteDeDatos{
    {method}agregarHecho(titulo:String, descripcion:String, ubicacion: Ubicacion, categoria: String, multimedia: Multimedia, fecha:Date, anonimidad:Boolean)
}

class FuenteProxy implements FuenteDeDatos{
    {method}agregarHecho(titulo:String, descripcion:String, ubicacion: Ubicacion, categoria: String, multimedia: Multimedia, fecha:Date)
}

'-----------------Colecciones----------------

class Coleccion{
    +titulo: String
    +descripcion: String
    +criterioPertenencia: List<Criterio>
    +fuenteDeDatos: FuenteDeDatos
    +handle: String
    {method}agregarCriterioPertenencia(criterio:Criterio)
    {method}eliminarCriterioPertenencia(criterio:Criterio)
    {method}filtrarPorCriterios(criterios:List<Criterio>)
}





'-----------------Solicitud de eliminacion----------------

class SolicitudEliminacion{
    +hechoAEliminar: Hecho
    +motivo: String
    -estado: EstadoSolicitud
    {method}aceptarSolicitud()
    {method}rechazarSolicitud()
}

enum EstadoSolicitud{
    PENDIENTE
    APROBADA
    RECHAZADA
}


interface DetectorDeSpam {
    +esSpam(texto: String): Boolean
}

class DetectorDeSpamService {
    -detector: DetectorDeSpam
    crearSolicitud(perfil: Perfil, hecho: Hecho, motivo: String)
}


' ----Usuario rol perfil ----

class Usuario{
    -email: String
    -contraseñaHasheada: String
    -roles: list<Rol>
    {method}tieneRol(rol:Rol)
}

enum Rol{
    CONTRIBUYENTE
    ADMINISTRADOR 
}

class Perfil{
    +nombre: String
    +apellido: String
    +edad: Int
    +usuario: Usuario
    +solicitudesEliminacion: List<SolicitudEliminacion>
}

' -----------Criterios-----------------
interface Criterio{ 
    {method}cumple(Hecho)
}
class CriterioFecha implements Criterio{
    +fechaDesde:Date
    +fechaHasta:Date
    {method}cumple(Hecho)
}
class CriterioTitulo implements Criterio{
    +titulo:String 
    {method}cumple(Hecho)
}
class CriterioDescripcion implements Criterio{
    +descripcion:String
    {method}cumple(Hecho)
}
class CriterioCategoria implements Criterio{
    +categoria:String
    {method}cumple(Hecho)
}
class CriterioZona implements Criterio{
    +latitud:Float
    +longitud:Float
    {method}cumple(Hecho)
}
class CriterioOrigen implements Criterio{
    +origen:FuenteDeDatos
    {method}cumple(Hecho)
}
class CriterioMultimedia implements Criterio{
    +multimedia:Multimedia
    {method}cumple(Hecho)
}


@enduml